<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pit Stop Challenge - Multiplayer</title>
    <script src="https://unpkg.com/peerjs@1.5.0/dist/peerjs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
        body {
            font-family: 'Arial', sans-serif;
            background: #000;
            overflow: hidden;
            touch-action: none;
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            background: #000;
        }
        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }
        
        /* Screens */
        .screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #000000 0%, #0f0f0f 50%, #1a1a1a 100%);
            color: #0f0;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 100;
            padding: 20px;
            overflow-y: auto;
        }
        .screen.active {
            display: flex;
        }
        .screen h1 {
            font-size: 2.5em;
            margin-bottom: 30px;
            text-shadow: 0 0 20px #0f0, 0 0 40px #0f0;
            color: #0f0;
        }
        .screen h2 {
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
        }
        input, button, select {
            margin: 8px;
            padding: 15px 25px;
            font-size: 16px;
            border: 2px solid #0f0;
            border-radius: 12px;
            font-weight: bold;
            min-width: 200px;
            max-width: 90%;
            background: #000;
            color: #0f0;
            box-shadow: 0 0 10px rgba(0,255,0,0.3);
        }
        button {
            cursor: pointer;
            transition: all 0.2s;
        }
        button:active {
            transform: scale(0.95);
            box-shadow: 0 0 20px rgba(0,255,0,0.6);
        }
        button:hover {
            background: #0f0;
            color: #000;
            box-shadow: 0 0 30px rgba(0,255,0,0.8);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        input::placeholder {
            color: #0a0;
        }
        
        /* Waiting Room */
        #players-list {
            list-style: none;
            padding: 20px;
            background: rgba(0,255,0,0.1);
            border: 2px solid #0f0;
            border-radius: 10px;
            min-width: 300px;
            margin: 20px 0;
        }
        #players-list li {
            padding: 10px;
            margin: 5px 0;
            background: rgba(0,255,0,0.2);
            border-radius: 5px;
            color: #0f0;
        }
        .room-info {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(0,255,0,0.05);
            border: 2px solid #0f0;
            border-radius: 15px;
        }
        .room-code {
            font-size: 3em;
            letter-spacing: 15px;
            padding: 15px 30px;
            background: rgba(0,255,0,0.2);
            border: 3px solid #0f0;
            border-radius: 10px;
            color: #0f0;
            text-shadow: 0 0 20px #0f0;
        }
        #qrcode {
            padding: 10px;
            background: white;
            border-radius: 10px;
            margin: 10px 0;
        }
        #qrcode canvas {
            display: block;
        }
        .share-instruction {
            font-size: 14px;
            color: #0a0;
            text-align: center;
            max-width: 300px;
            line-height: 1.4;
        }
        .copy-btn {
            min-width: 150px;
            padding: 10px 20px;
            font-size: 14px;
        }
        
        /* Race HUD */
        #race-hud {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            padding: 10px;
            background: linear-gradient(180deg, rgba(0,0,0,0.9) 0%, transparent 100%);
            z-index: 10;
            pointer-events: none;
        }
        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #0f0;
            font-size: 18px;
            font-weight: bold;
            text-shadow: 0 0 10px #0f0;
        }
        .hud-stat {
            display: flex;
            flex-direction: column;
            align-items: center;
            background: rgba(0,0,0,0.8);
            border: 2px solid #0f0;
            padding: 8px 15px;
            border-radius: 10px;
            min-width: 80px;
        }
        .hud-label {
            font-size: 12px;
            color: #0a0;
            margin-bottom: 2px;
        }
        .hud-value {
            font-size: 24px;
            color: #0f0;
            text-shadow: 0 0 10px #0f0;
        }
        #speed-display {
            font-size: 32px;
            color: #0f0;
        }
        
        /* Scoreboard */
        #scoreboard {
            position: absolute;
            top: 80px;
            left: 10px;
            background: rgba(0,0,0,0.9);
            border: 3px solid #0f0;
            border-radius: 10px;
            padding: 15px;
            min-width: 200px;
            z-index: 10;
            box-shadow: 0 0 20px rgba(0,255,0,0.5);
        }
        #scoreboard h3 {
            color: #0f0;
            margin-bottom: 10px;
            text-align: center;
            font-size: 16px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .scoreboard-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 10px;
            margin: 5px 0;
            background: rgba(0,255,0,0.1);
            border-radius: 5px;
            border-left: 3px solid;
            font-size: 14px;
        }
        .scoreboard-row.you {
            background: rgba(0,255,0,0.3);
            font-weight: bold;
        }
        .scoreboard-position {
            font-weight: bold;
            margin-right: 8px;
            min-width: 25px;
        }
        .scoreboard-name {
            flex: 1;
            color: #0f0;
        }
        .scoreboard-lap {
            color: #0a0;
            font-size: 12px;
            margin-left: 10px;
        }
        
        /* Minimap */
        #minimap {
            position: absolute;
            top: 80px;
            right: 10px;
            width: 180px;
            height: 180px;
            background: rgba(0,0,0,0.9);
            border: 3px solid #0f0;
            border-radius: 10px;
            z-index: 10;
            box-shadow: 0 0 20px rgba(0,255,0,0.5);
        }
        
        /* Question Popup */
        #question-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #000;
            border: 3px solid #0f0;
            box-shadow: 0 0 40px rgba(0,255,0,0.8);
            color: #0f0;
            padding: 25px;
            border-radius: 20px;
            max-width: 90vw;
            max-height: 85vh;
            overflow-y: auto;
            z-index: 50;
        }
        #question-popup.hidden {
            display: none;
        }
        .question-header {
            text-align: center;
            margin-bottom: 20px;
        }
        .category-badge {
            display: inline-block;
            padding: 5px 15px;
            background: rgba(0,255,0,0.2);
            border: 1px solid #0f0;
            border-radius: 20px;
            font-size: 12px;
            margin-bottom: 10px;
        }
        #question-text {
            font-size: 18px;
            line-height: 1.6;
            margin-bottom: 15px;
            text-align: left;
        }
        #timer {
            font-size: 48px;
            text-align: center;
            color: #0f0;
            text-shadow: 0 0 20px #0f0;
            margin: 15px 0;
        }
        #timer.warning {
            color: #f00;
            text-shadow: 0 0 20px #f00;
            animation: pulse 0.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.15); }
        }
        .options {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 15px;
        }
        .option-btn {
            padding: 15px;
            font-size: 16px;
            background: #000;
            color: #0f0;
            border: 2px solid #0f0;
            text-align: left;
            transition: all 0.2s;
        }
        .option-btn:active {
            transform: scale(0.98);
        }
        .option-btn:hover {
            background: rgba(0,255,0,0.2);
        }
        .option-btn.correct {
            background: #0f0;
            color: #000;
            border-color: #0f0;
        }
        .option-btn.wrong {
            background: #f00;
            color: #fff;
            border-color: #f00;
        }
        .option-btn:disabled {
            opacity: 0.7;
        }
        #explanation {
            margin-top: 15px;
            padding: 15px;
            background: rgba(0,255,0,0.1);
            border: 1px solid #0f0;
            border-radius: 10px;
            display: none;
            font-size: 14px;
            line-height: 1.5;
        }
        
        /* Mobile Controls */
        #controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 220px;
            z-index: 20;
            pointer-events: none;
        }
        .control-btn {
            position: absolute;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 18px;
            font-weight: bold;
            color: #0f0;
            border-radius: 50%;
            pointer-events: auto;
            user-select: none;
            box-shadow: 0 0 20px rgba(0,255,0,0.5);
            border: 4px solid #0f0;
            background: rgba(0,0,0,0.8);
            transition: transform 0.1s;
        }
        .control-btn:active {
            transform: scale(0.9);
        }
        #steer-left {
            bottom: 20px;
            left: 20px;
            width: 90px;
            height: 90px;
        }
        #steer-right {
            bottom: 20px;
            left: 120px;
            width: 90px;
            height: 90px;
        }
        #accelerate {
            bottom: 40px;
            right: 20px;
            width: 110px;
            height: 110px;
            font-size: 24px;
        }
        #brake {
            bottom: 130px;
            right: 40px;
            width: 70px;
            height: 70px;
            font-size: 16px;
        }
        .control-btn.active {
            transform: scale(0.85);
            background: #0f0;
            color: #000;
            box-shadow: 0 0 40px rgba(0,255,0,1);
        }
        
        /* Effects */
        #effect-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #effect-overlay.boost {
            background: radial-gradient(circle at center, transparent 20%, rgba(0,255,0,0.4) 100%);
            opacity: 1;
            animation: boost-pulse 0.3s infinite;
        }
        #effect-overlay.slow {
            background: radial-gradient(circle at center, transparent 20%, rgba(255,0,0,0.3) 100%);
            opacity: 1;
        }
        #effect-overlay.crash {
            background: rgba(255,0,0,0.5);
            opacity: 1;
            animation: crash-flash 0.3s;
        }
        @keyframes boost-pulse {
            0%, 100% { opacity: 0.9; }
            50% { opacity: 1; }
        }
        @keyframes crash-flash {
            0%, 100% { opacity: 0; }
            50% { opacity: 1; }
        }
        
        /* Countdown */
        #countdown-text {
            font-size: 15vh;
            color: #0f0;
            text-shadow: 0 0 40px #0f0, 0 0 80px #0f0;
            animation: countdown-pop 0.8s;
        }
        @keyframes countdown-pop {
            0% { transform: scale(0); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }
        
        /* Results */
        #results-content {
            width: 100%;
            max-width: 400px;
        }
        .result-item {
            background: rgba(0,255,0,0.1);
            border: 1px solid #0f0;
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #0f0;
        }
        .result-item.first {
            background: rgba(0,255,0,0.3);
            border: 3px solid #0f0;
            font-size: 1.2em;
            box-shadow: 0 0 30px rgba(0,255,0,0.5);
        }
        .result-item.second {
            background: rgba(0,255,0,0.2);
            border: 2px solid #0f0;
        }
        .result-item.third {
            background: rgba(0,255,0,0.15);
            border: 2px solid #0a0;
        }
        
        .loading {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 4px solid rgba(0,255,0,0.3);
            border-radius: 50%;
            border-top-color: #0f0;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .instruction {
            position: absolute;
            bottom: 240px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.95);
            border: 3px solid #0f0;
            color: #0f0;
            padding: 20px 30px;
            border-radius: 15px;
            font-size: 18px;
            text-align: center;
            z-index: 25;
            animation: float 2s ease-in-out infinite;
            box-shadow: 0 0 30px rgba(0,255,0,0.7);
            font-weight: bold;
        }
        @keyframes float {
            0%, 100% { transform: translateX(-50%) translateY(0); }
            50% { transform: translateX(-50%) translateY(-10px); }
        }
        .instruction.hidden {
            display: none;
        }

        .status-message {
            color: #0f0;
            font-size: 14px;
            margin: 10px 0;
            text-align: center;
            min-height: 20px;
        }
        .status-message.error {
            color: #f00;
        }

        /* Boost notification */
        #boost-notification {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,255,0,0.95);
            color: #000;
            padding: 30px 50px;
            border-radius: 20px;
            font-size: 36px;
            font-weight: bold;
            z-index: 45;
            display: none;
            text-shadow: none;
            box-shadow: 0 0 50px rgba(0,255,0,1);
            animation: boost-appear 0.5s;
        }
        @keyframes boost-appear {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .connection-status {
            font-size: 12px;
            color: #0a0;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="canvas"></canvas>
        <canvas id="minimap"></canvas>
        <div id="effect-overlay"></div>
        
        <!-- Race HUD -->
        <div id="race-hud" style="display: none;">
            <div class="hud-top">
                <div class="hud-stat">
                    <div class="hud-label">SPEED</div>
                    <div class="hud-value" id="speed-display">0</div>
                </div>
                <div class="hud-stat">
                    <div class="hud-label">LAP</div>
                    <div class="hud-value" id="lap-display">1/3</div>
                </div>
                <div class="hud-stat">
                    <div class="hud-label">POS</div>
                    <div class="hud-value" id="pos-display">1st</div>
                </div>
                <div class="hud-stat">
                    <div class="hud-label">CORRECT</div>
                    <div class="hud-value" id="correct-display">0</div>
                </div>
            </div>
        </div>

        <!-- Scoreboard -->
        <div id="scoreboard" style="display: none;">
            <h3>Leaderboard</h3>
            <div id="scoreboard-content"></div>
        </div>
        
        <!-- Lobby Screen -->
        <div id="lobby" class="screen active">
            <h1>üèÅ PIT STOP CHALLENGE</h1>
            <p style="margin-bottom: 20px; font-size: 14px; text-align: center;">Race first, learn second - answer questions for MEGA BOOST!</p>
            <input type="text" id="player-name" placeholder="Your Name" maxlength="20">
            <select id="category-select">
                <option value="all">All Categories</option>
                <option value="Service Information">Service Information</option>
                <option value="Vehicle Preparation">Vehicle Preparation</option>
                <option value="After Work">After Work</option>
                <option value="Scenarios">Scenarios</option>
            </select>
            <select id="difficulty-select">
                <option value="all">All Difficulties</option>
                <option value="easy">Easy</option>
                <option value="medium">Medium</option>
                <option value="hard">Hard</option>
            </select>
            <button id="play-solo">üéÆ Solo Race</button>
            <button id="create-room">üåê Create Multiplayer Room</button>
            <p style="font-size: 12px; color: #0a0; margin: 10px 0;">To join a room, scan the QR code or use the link shared by the host</p>
            <div style="display: flex; gap: 10px; align-items: center;">
                <input type="text" id="room-code" placeholder="ROOM CODE" maxlength="6" style="width: 150px; text-align: center; text-transform: uppercase;">
                <button id="join-room">Join Room</button>
            </div>
            <div class="status-message" id="status-message"></div>
        </div>
        
        <!-- Waiting Room -->
        <div id="waiting-room" class="screen">
            <h1>WAITING ROOM</h1>
            <div class="room-info">
                <div>
                    <p style="text-align: center; margin-bottom: 10px; font-size: 14px;">Room Code:</p>
                    <div class="room-code" id="display-room-code">----</div>
                </div>
                <div id="qrcode"></div>
                <button class="copy-btn" id="copy-link-btn">üìã Copy Join Link</button>
                <p class="share-instruction">Players MUST use the QR code or copied link to join!<br>The room code alone won't work.</p>
                <p class="connection-status" id="connection-status">Initializing...</p>
            </div>
            <p style="margin-bottom: 10px; font-weight: bold;">Players in Room:</p>
            <ul id="players-list"></ul>
            <button id="start-race" style="display: none;">üèÅ START RACE</button>
            <button id="leave-room">‚Üê Leave Room</button>
        </div>
        
        <!-- Countdown Screen -->
        <div id="countdown" class="screen">
            <h1 id="countdown-text">3</h1>
        </div>
        
        <!-- Results Screen -->
        <div id="results" class="screen">
            <h1>üèÜ RACE COMPLETE</h1>
            <div id="results-content"></div>
            <button id="race-again">üîÑ Race Again</button>
            <button id="back-to-menu">‚Üê Back to Menu</button>
        </div>
        
        <!-- Question Popup -->
        <div id="question-popup" class="hidden">
            <div class="question-header">
                <div class="category-badge" id="question-category"></div>
            </div>
            <div id="question-text"></div>
            <div id="timer">20</div>
            <div class="options" id="options"></div>
            <div id="explanation"></div>
        </div>
        
        <!-- Mobile Controls -->
        <div id="controls" style="display: none;">
            <div class="control-btn" id="steer-left">‚óÄ</div>
            <div class="control-btn" id="steer-right">‚ñ∂</div>
            <div class="control-btn" id="brake">BRAKE</div>
            <div class="control-btn" id="accelerate">GO!</div>
        </div>

        <!-- Instruction -->
        <div class="instruction hidden" id="instruction">
            Feel the speed! Complete lap 1 first üèÅ
        </div>

        <!-- Boost Notification -->
        <div id="boost-notification">‚ö° MEGA BOOST! ‚ö°</div>
    </div>
    
    <script src="questions/questions.js"></script>
    <script>
        // ============================================
        // GAME CONSTANTS
        // ============================================
        const GAME_WIDTH = 6000;
        const GAME_HEIGHT = 4800;
        const CAR_LENGTH = 40;
        const CAR_WIDTH = 20;
        const TRACK_WIDTH = 150;
        const MAX_SPEED = 4.5;
        const ACCELERATION = 0.08;
        const BRAKE_POWER = 0.25;
        const FRICTION = 0.05;
        const TURN_SPEED = 0.065;
        const DRIFT = 0.94;
        const BOOST_MULT = 2.5;
        const SLOW_MULT = 0.5;
        const BOOST_TIME = 450;
        const SLOW_TIME = 180;
        const QUESTION_TIME = 1200;
        const CAMERA_SMOOTHING = 0.15;
        const ZOOM = 1.4;
        const CAMERA_Y_OFFSET = 140;
        const COLLISION_RADIUS = 35;
        const CRASH_SPEED_LOSS = 0.5;
        const CRASH_STUN_TIME = 40;

        const PLAYER_COLORS = [
            '#00ff00', '#00ffff', '#ff00ff', '#ffff00',
            '#ff6600', '#ff0066', '#6600ff', '#00ff66',
        ];

        // ============================================
        // MULTIPLAYER STATE
        // ============================================
        let peer = null;
        let myPeerId = null;
        let roomCode = '';
        let isHost = false;
        let connections = new Map();
        let players = new Map();
        let localPlayerId = null;
        let playerColorIndex = 0;

        // ============================================
        // CANVAS SETUP
        // ============================================
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const minimapCanvas = document.getElementById('minimap');
        const minimapCtx = minimapCanvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            minimapCanvas.width = 180;
            minimapCanvas.height = 180;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        // Check URL for room code and host peer ID
        const urlParams = new URLSearchParams(window.location.search);
        const urlRoomCode = urlParams.get('room');
        const urlHostPeerId = urlParams.get('host');
        if (urlRoomCode) {
            document.getElementById('room-code').value = urlRoomCode.toUpperCase();
        }

        // ============================================
        // ROOM CODE FUNCTIONS
        // ============================================
        function generateRoomCode() {
            // Generate a 6-character alphanumeric code
            const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // Exclude similar looking chars
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }

        function generateQRCode(roomCode, hostPeerId) {
            const qrcodeEl = document.getElementById('qrcode');
            qrcodeEl.innerHTML = '';
            
            const baseUrl = window.location.origin + window.location.pathname;
            // Include BOTH room code (for display) and host peer ID (for connection)
            const fullUrl = `${baseUrl}?room=${roomCode}&host=${hostPeerId}`;
            
            QRCode.toCanvas(fullUrl, {
                width: 200,
                margin: 2,
                color: {
                    dark: '#000000',
                    light: '#ffffff'
                }
            }, function (err, canvas) {
                if (err) {
                    console.error('QR Code generation failed:', err);
                    qrcodeEl.innerHTML = '<p style="color: #f00;">QR Code failed to generate</p>';
                } else {
                    qrcodeEl.appendChild(canvas);
                }
            });
        }

        function copyRoomLink() {
            const baseUrl = window.location.origin + window.location.pathname;
            const fullUrl = `${baseUrl}?room=${roomCode}&host=${myPeerId}`;
            
            navigator.clipboard.writeText(fullUrl).then(() => {
                const btn = document.getElementById('copy-link-btn');
                const originalText = btn.textContent;
                btn.textContent = '‚úÖ Copied!';
                setTimeout(() => {
                    btn.textContent = originalText;
                }, 2000);
            }).catch(err => {
                console.error('Failed to copy:', err);
                alert('Copy link: ' + fullUrl);
            });
        }

        // ============================================
        // TRACK GENERATION
        // ============================================
        function createTrack() {
            const cx = GAME_WIDTH / 2;
            const cy = GAME_HEIGHT / 2;
            
            const trackSegments = [
                {x: cx - 1400, y: cy + 1000}, {x: cx - 1200, y: cy + 1000}, {x: cx - 1000, y: cy + 1000},
                {x: cx - 800, y: cy + 1000}, {x: cx - 600, y: cy + 1000}, {x: cx - 400, y: cy + 1000},
                {x: cx - 200, y: cy + 1000}, {x: cx, y: cy + 1000}, {x: cx + 200, y: cy + 1000},
                {x: cx + 400, y: cy + 1000}, {x: cx + 600, y: cy + 1000}, {x: cx + 800, y: cy + 1000},
                {x: cx + 1000, y: cy + 1000}, {x: cx + 1200, y: cy + 960}, {x: cx + 1400, y: cy + 880},
                {x: cx + 1560, y: cy + 760}, {x: cx + 1680, y: cy + 600}, {x: cx + 1760, y: cy + 400},
                {x: cx + 1800, y: cy + 200}, {x: cx + 1800, y: cy}, {x: cx + 1780, y: cy - 200},
                {x: cx + 1720, y: cy - 400}, {x: cx + 1620, y: cy - 560}, {x: cx + 1480, y: cy - 700},
                {x: cx + 1300, y: cy - 800}, {x: cx + 1100, y: cy - 840}, {x: cx + 900, y: cy - 860},
                {x: cx + 700, y: cy - 880}, {x: cx + 500, y: cy - 890}, {x: cx + 300, y: cy - 900},
                {x: cx + 100, y: cy - 900}, {x: cx - 100, y: cy - 900}, {x: cx - 300, y: cy - 900},
                {x: cx - 500, y: cy - 900}, {x: cx - 660, y: cy - 880}, {x: cx - 800, y: cy - 820},
                {x: cx - 900, y: cy - 720}, {x: cx - 960, y: cy - 600}, {x: cx - 1000, y: cy - 460},
                {x: cx - 980, y: cy - 320}, {x: cx - 940, y: cy - 160}, {x: cx - 880, y: cy},
                {x: cx - 800, y: cy + 140}, {x: cx - 700, y: cy + 260}, {x: cx - 580, y: cy + 360},
                {x: cx - 440, y: cy + 440}, {x: cx - 300, y: cy + 480}, {x: cx - 160, y: cy + 500},
                {x: cx - 20, y: cy + 480}, {x: cx + 100, y: cy + 420}, {x: cx + 200, y: cy + 340},
                {x: cx + 280, y: cy + 240}, {x: cx + 320, y: cy + 120}, {x: cx + 330, y: cy},
                {x: cx + 320, y: cy - 120}, {x: cx + 280, y: cy - 240}, {x: cx + 200, y: cy - 340},
                {x: cx + 100, y: cy - 420}, {x: cx, y: cy - 480}, {x: cx - 120, y: cy - 520},
                {x: cx - 260, y: cy - 540}, {x: cx - 400, y: cy - 520}, {x: cx - 540, y: cy - 460},
                {x: cx - 660, y: cy - 360}, {x: cx - 760, y: cy - 220}, {x: cx - 840, y: cy - 60},
                {x: cx - 900, y: cy + 100}, {x: cx - 960, y: cy + 280}, {x: cx - 1040, y: cy + 460},
                {x: cx - 1140, y: cy + 620}, {x: cx - 1260, y: cy + 760}, {x: cx - 1400, y: cy + 860},
                {x: cx - 1560, y: cy + 940}, {x: cx - 1720, y: cy + 980}, {x: cx - 1880, y: cy + 1000},
                {x: cx - 2000, y: cy + 980}, {x: cx - 2100, y: cy + 920}, {x: cx - 2160, y: cy + 820},
                {x: cx - 2200, y: cy + 700}, {x: cx - 2200, y: cy + 560}, {x: cx - 2160, y: cy + 420},
                {x: cx - 2080, y: cy + 300}, {x: cx - 1960, y: cy + 220}, {x: cx - 1820, y: cy + 180},
                {x: cx - 1680, y: cy + 180}, {x: cx - 1540, y: cy + 220}, {x: cx - 1420, y: cy + 300},
                {x: cx - 1320, y: cy + 420}, {x: cx - 1260, y: cy + 560}, {x: cx - 1240, y: cy + 700},
                {x: cx - 1260, y: cy + 840}, {x: cx - 1320, y: cy + 960}, {x: cx - 1400, y: cy + 1000}
            ];

            return trackSegments;
        }
        
        const track = createTrack();
        const FINISH_LINE_ANGLE = Math.atan2(track[1].y - track[0].y, track[1].x - track[0].x);

        // ============================================
        // GAME STATE
        // ============================================
        let gameState = 'lobby';
        let playerName = localStorage.getItem('playerName') || '';
        let selectedCategory = 'all';
        let selectedDifficulty = 'all';
        let raceStarted = false;
        let startTime = 0;
        let currentQuestion = null;
        let questionTimer = 0;
        let particles = [];
        let questions = [];
        let questionsPlaced = false;
        let cameraX = 0;
        let cameraY = 0;
        let cameraAngle = 0;
        let keys = {left: false, right: false, up: false, down: false};
        let trackCrossings = [];
        let touchLeft = false;
        let touchRight = false;
        let touchAccel = false;
        let touchBrake = false;

        function detectTrackCrossings() {
            trackCrossings = [];
            function segIntersect(a1, a2, b1, b2) {
                const dx1 = a2.x - a1.x, dy1 = a2.y - a1.y;
                const dx2 = b2.x - b1.x, dy2 = b2.y - b1.y;
                const denom = dx1 * dy2 - dy1 * dx2;
                if (Math.abs(denom) < 1e-6) return null;
                const t = ((b1.x - a1.x) * dy2 - (b1.y - a1.y) * dx2) / denom;
                const u = ((b1.x - a1.x) * dy1 - (b1.y - a1.y) * dx1) / denom;
                if (t > 0 && t < 1 && u > 0 && u < 1) {
                    return {x: a1.x + dx1 * t, y: a1.y + dy1 * t};
                }
                return null;
            }

            for (let i = 0; i < track.length; i++) {
                const a1 = track[i];
                const a2 = track[(i + 1) % track.length];
                for (let j = i + 2; j < track.length; j++) {
                    if (j === i || j === (i + 1) % track.length || (i === 0 && j === track.length - 1)) continue;
                    const b1 = track[j];
                    const b2 = track[(j + 1) % track.length];
                    const p = segIntersect(a1, a2, b1, b2);
                    if (p) {
                        const angle = Math.atan2(a2.y - a1.y, a2.x - a1.x);
                        trackCrossings.push({x: p.x, y: p.y, angle});
                    }
                }
            }

            const dedup = [];
            trackCrossings.forEach(c => {
                if (!dedup.some(d => Math.hypot(d.x - c.x, d.y - c.y) < 12)) dedup.push(c);
            });
            trackCrossings = dedup;
        }

        detectTrackCrossings();

        // ============================================
        // PLAYER CLASS
        // ============================================
        class Player {
            constructor(id, name, colorIndex) {
                this.id = id;
                this.name = name;
                this.x = track[0].x;
                this.y = track[0].y;
                this.vx = 0;
                this.vy = 0;
                this.angle = FINISH_LINE_ANGLE;
                this.speed = 0;
                this.lap = 0;
                this.checkpoint = 0;
                this.boost = 0;
                this.slow = 0;
                this.crashStun = 0;
                this.questionsCorrect = 0;
                this.questionsThisLap = 0;
                this.finished = false;
                this.finishTime = null;
                this.crossedStartFromBehind = false;
                this.color = PLAYER_COLORS[colorIndex % PLAYER_COLORS.length];
                this.colorIndex = colorIndex;
            }

            update(input) {
                if (this.crashStun > 0) {
                    this.crashStun--;
                    input = {up: false, down: false, left: false, right: false};
                }

                let speedMult = 1;
                if (this.boost > 0) {
                    speedMult = BOOST_MULT;
                    this.boost--;
                } else if (this.slow > 0) {
                    speedMult = SLOW_MULT;
                    this.slow--;
                }

                if (input.up) {
                    this.speed = Math.min(this.speed + ACCELERATION, MAX_SPEED * speedMult);
                }
                if (input.down) {
                    this.speed = Math.max(this.speed - BRAKE_POWER, 0);
                }
                if (!input.up && !input.down) {
                    this.speed *= (1 - FRICTION);
                }
                
                if (input.left) {
                    this.angle -= TURN_SPEED * Math.min(this.speed / MAX_SPEED + 0.3, 1);
                }
                if (input.right) {
                    this.angle += TURN_SPEED * Math.min(this.speed / MAX_SPEED + 0.3, 1);
                }

                this.vx += Math.cos(this.angle) * this.speed * 0.35;
                this.vy += Math.sin(this.angle) * this.speed * 0.35;
                this.vx *= DRIFT;
                this.vy *= DRIFT;
                
                this.x += this.vx;
                this.y += this.vy;

                if (distanceToTrack({x: this.x, y: this.y}) > TRACK_WIDTH) {
                    this.speed *= 0.7;
                    this.vx *= 0.7;
                    this.vy *= 0.7;
                }

                this.updateLap();
            }

            updateLap() {
                const currentIdx = getClosestTrackIndex({x: this.x, y: this.y});
                
                if (currentIdx > track.length / 2) {
                    this.crossedStartFromBehind = true;
                }
                
                if (currentIdx < 5 && this.crossedStartFromBehind) {
                    const dx = this.x - track[0].x;
                    const dy = this.y - track[0].y;
                    const approachAngle = Math.atan2(dy, dx);
                    const angleDiff = Math.abs(((approachAngle - FINISH_LINE_ANGLE + Math.PI) % (2 * Math.PI)) - Math.PI);
                    
                    if (angleDiff < Math.PI / 2) {
                        if (this.lap === 0) {
                            this.lap++;
                            this.questionsThisLap = 0;
                            this.checkpoint = 0;
                            this.crossedStartFromBehind = false;
                            
                            if (this.id === localPlayerId) {
                                if (isHost && !questionsPlaced) {
                                    initQuestions();
                                    questionsPlaced = true;
                                    broadcast({
                                        type: 'place-questions',
                                        questions: questions
                                    });
                                }
                                
                                showInstruction('üéØ Questions UNLOCKED! Grab them for MEGA BOOST! ‚ö°', 5000);
                            }
                        } else if (this.questionsThisLap > 0) {
                            this.lap++;
                            this.questionsThisLap = 0;
                            this.checkpoint = 0;
                            this.crossedStartFromBehind = false;
                            
                            if (this.lap >= 3 && !this.finished) {
                                this.finished = true;
                                this.finishTime = Date.now() - startTime;
                                
                                if (this.id === localPlayerId) {
                                    broadcast({
                                        type: 'player-finished',
                                        playerId: this.id,
                                        finishTime: this.finishTime
                                    });
                                }
                            }
                        } else {
                            this.crossedStartFromBehind = false;
                        }
                    }
                }
                
                if (currentIdx > this.checkpoint + 5) {
                    this.checkpoint = currentIdx;
                }
            }

            handleCollision(other) {
                const dx = other.x - this.x;
                const dy = other.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < COLLISION_RADIUS && dist > 0) {
                    const nx = dx / dist;
                    const ny = dy / dist;
                    
                    const dvx = other.vx - this.vx;
                    const dvy = other.vy - this.vy;
                    const dvn = dvx * nx + dvy * ny;
                    
                    if (dvn >= 0) return false;
                    
                    const impulse = dvn * 0.5;
                    this.vx += impulse * nx;
                    this.vy += impulse * ny;
                    
                    const overlap = COLLISION_RADIUS - dist;
                    this.x -= nx * overlap * 0.5;
                    this.y -= ny * overlap * 0.5;
                    
                    this.speed *= CRASH_SPEED_LOSS;
                    this.crashStun = CRASH_STUN_TIME;
                    
                    if (this.id === localPlayerId) {
                        document.getElementById('effect-overlay').className = 'crash';
                        setTimeout(() => {
                            if (document.getElementById('effect-overlay').className === 'crash') {
                                document.getElementById('effect-overlay').className = '';
                            }
                        }, 300);
                        
                        for (let i = 0; i < 15; i++) {
                            createParticle(this.x, this.y, '#f00', 6,
                                (Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10, 30);
                        }
                        
                        playSound(150, 0.2);
                    }
                    
                    return true;
                }
                return false;
            }

            toData() {
                return {
                    id: this.id, name: this.name, x: this.x, y: this.y,
                    vx: this.vx, vy: this.vy, angle: this.angle, speed: this.speed,
                    lap: this.lap, checkpoint: this.checkpoint,
                    boost: this.boost, slow: this.slow, crashStun: this.crashStun,
                    questionsCorrect: this.questionsCorrect, questionsThisLap: this.questionsThisLap,
                    finished: this.finished, finishTime: this.finishTime,
                    colorIndex: this.colorIndex
                };
            }

            fromData(data) {
                Object.assign(this, data);
                this.color = PLAYER_COLORS[data.colorIndex % PLAYER_COLORS.length];
            }
        }

        // ============================================
        // PEER JS / WebRTC CONNECTION
        // ============================================
        function initPeer() {
            return new Promise((resolve, reject) => {
                // Use PeerJS cloud server
                peer = new Peer({
                    config: {
                        iceServers: [
                            { urls: 'stun:stun.l.google.com:19302' },
                            { urls: 'stun:stun1.l.google.com:19302' }
                        ]
                    }
                });
                
                peer.on('open', (id) => {
                    myPeerId = id;
                    localPlayerId = id;
                    console.log('Peer connected with ID:', id);
                    updateConnectionStatus('Connected to server');
                    resolve(id);
                });

                peer.on('error', (err) => {
                    console.error('Peer error:', err);
                    updateConnectionStatus('Connection error: ' + err.type, true);
                    showStatus('Connection error. Please try again.', true);
                    reject(err);
                });

                peer.on('connection', (conn) => {
                    console.log('Incoming connection from:', conn.peer);
                    setupConnection(conn);
                });

                peer.on('disconnected', () => {
                    console.log('Disconnected from server');
                    updateConnectionStatus('Disconnected - reconnecting...', true);
                    // Try to reconnect
                    setTimeout(() => {
                        if (peer && !peer.destroyed) {
                            peer.reconnect();
                        }
                    }, 1000);
                });
            });
        }

        function setupConnection(conn) {
            connections.set(conn.peer, conn);
            
            conn.on('open', () => {
                console.log('Connection opened with:', conn.peer);
                updateConnectionStatus('Connected to ' + (isHost ? 'player' : 'host'));
                
                if (isHost) {
                    // Host sends full game state to new player
                    const playersData = Array.from(players.values()).map(p => p.toData());
                    conn.send({
                        type: 'init',
                        players: playersData,
                        questions: questions,
                        questionsPlaced: questionsPlaced,
                        roomCode: roomCode,
                        hostPeerId: myPeerId,
                        nextColorIndex: playerColorIndex
                    });
                    console.log('Sent init data to new player');
                } else {
                    // Client sends join request
                    const localPlayer = players.get(localPlayerId);
                    conn.send({
                        type: 'join-request',
                        player: localPlayer.toData()
                    });
                    console.log('Sent join request to host');
                }
            });

            conn.on('data', (data) => {
                handleMessage(data, conn);
            });

            conn.on('close', () => {
                console.log('Connection closed with:', conn.peer);
                connections.delete(conn.peer);
                players.delete(conn.peer);
                updateWaitingRoom();
                updateScoreboard();
                updateConnectionStatus('Player disconnected');
            });

            conn.on('error', (err) => {
                console.error('Connection error with', conn.peer, ':', err);
                connections.delete(conn.peer);
                players.delete(conn.peer);
                updateWaitingRoom();
            });
        }

        function handleMessage(data, conn) {
            switch (data.type) {
                case 'init':
                    console.log('Received init data');
                    roomCode = data.roomCode;
                    questions = data.questions;
                    questionsPlaced = data.questionsPlaced;
                    playerColorIndex = data.nextColorIndex;
                    
                    // Update local player's color
                    const localPlayer = players.get(localPlayerId);
                    if (localPlayer) {
                        localPlayer.colorIndex = playerColorIndex;
                        localPlayer.color = PLAYER_COLORS[playerColorIndex % PLAYER_COLORS.length];
                    }
                    
                    // Add other players
                    data.players.forEach(pData => {
                        if (!players.has(pData.id)) {
                            const p = new Player(pData.id, pData.name, pData.colorIndex);
                            p.fromData(pData);
                            players.set(pData.id, p);
                        }
                    });
                    updateWaitingRoom();
                    updateConnectionStatus('Joined room successfully');
                    break;

                case 'join-request':
                    if (isHost) {
                        console.log('Player join request:', data.player.name);
                        const p = new Player(data.player.id, data.player.name, playerColorIndex++);
                        p.fromData(data.player);
                        p.colorIndex = playerColorIndex - 1;
                        p.color = PLAYER_COLORS[p.colorIndex % PLAYER_COLORS.length];
                        players.set(p.id, p);
                        updateWaitingRoom();
                        
                        // Broadcast to all other players
                        broadcast({type: 'player-joined', player: p.toData()}, conn.peer);
                        
                        // Send updated player list to the new player
                        const playersData = Array.from(players.values()).map(pl => pl.toData());
                        conn.send({
                            type: 'update-players',
                            players: playersData
                        });
                    }
                    break;

                case 'player-joined':
                    console.log('New player joined:', data.player.name);
                    if (!players.has(data.player.id)) {
                        const p = new Player(data.player.id, data.player.name, data.player.colorIndex);
                        p.fromData(data.player);
                        players.set(p.id, p);
                        updateWaitingRoom();
                    }
                    break;

                case 'update-players':
                    // Update the full player list (sent to new joiners)
                    data.players.forEach(pData => {
                        if (!players.has(pData.id)) {
                            const p = new Player(pData.id, pData.name, pData.colorIndex);
                            p.fromData(pData);
                            players.set(pData.id, p);
                        }
                    });
                    updateWaitingRoom();
                    break;

                case 'player-update':
                    if (players.has(data.playerId) && data.playerId !== localPlayerId) {
                        players.get(data.playerId).fromData(data.playerData);
                    }
                    break;

                case 'start-race':
                    console.log('Race starting!');
                    startRace();
                    break;

                case 'place-questions':
                    questions = data.questions;
                    questionsPlaced = true;
                    break;

                case 'question-collected':
                    const q = questions.find(qu => qu.id === data.questionId);
                    if (q) q.collected = true;
                    break;

                case 'player-finished':
                    if (players.has(data.playerId)) {
                        players.get(data.playerId).finished = true;
                        players.get(data.playerId).finishTime = data.finishTime;
                    }
                    break;
            }
        }

        function broadcast(data, excludePeerId = null) {
            connections.forEach((conn, peerId) => {
                if (conn.open && peerId !== excludePeerId) {
                    try {
                        conn.send(data);
                    } catch (err) {
                        console.error('Failed to send to', peerId, ':', err);
                    }
                }
            });
        }

        function updateConnectionStatus(msg, isError = false) {
            const el = document.getElementById('connection-status');
            if (el) {
                el.textContent = msg;
                el.style.color = isError ? '#f00' : '#0a0';
            }
        }

        function showStatus(msg, isError = false) {
            const el = document.getElementById('status-message');
            el.textContent = msg;
            el.className = 'status-message' + (isError ? ' error' : '');
        }

        // ============================================
        // ROOM MANAGEMENT
        // ============================================
        async function createRoom() {
            try {
                showStatus('Creating room...');
                await initPeer();
                
                roomCode = generateRoomCode();
                isHost = true;
                playerColorIndex = 1;
                
                const localPlayer = new Player(localPlayerId, playerName, 0);
                players.set(localPlayerId, localPlayer);
                
                showScreen('waiting-room');
                document.getElementById('display-room-code').textContent = roomCode;
                updateWaitingRoom();
                generateQRCode(roomCode, myPeerId); // Pass peer ID
                showStatus('');
                
                console.log('Room created:', roomCode, 'Host Peer ID:', myPeerId);
            } catch (err) {
                showStatus('Failed to create room: ' + err.message, true);
                console.error('Create room error:', err);
            }
        }

        async function joinRoom() {
            try {
                const code = document.getElementById('room-code').value.trim().toUpperCase();
                if (!code || code.length < 4) {
                    showStatus('Enter a valid room code', true);
                    return;
                }
                
                showStatus('Connecting to room...');
                await initPeer();
                
                // Get host peer ID from URL parameters
                const urlParams = new URLSearchParams(window.location.search);
                let hostPeerId = urlParams.get('host');
                
                if (!hostPeerId) {
                    // If no host in URL, show instructions
                    showStatus('Please use the link or QR code shared by the host to join!', true);
                    console.error('No host peer ID in URL. Need ?room=CODE&host=PEERID');
                    return;
                }
                
                isHost = false;
                roomCode = code;
                const localPlayer = new Player(localPlayerId, playerName, 0);
                players.set(localPlayerId, localPlayer);
                
                // Connect to host
                console.log('Connecting to host peer ID:', hostPeerId);
                const conn = peer.connect(hostPeerId, {
                    reliable: true,
                    serialization: 'json'
                });
                
                if (!conn) {
                    showStatus('Failed to create connection', true);
                    return;
                }
                
                setupConnection(conn);
                
                showScreen('waiting-room');
                document.getElementById('display-room-code').textContent = roomCode;
                updateWaitingRoom();
                showStatus('');
                
                // Add timeout for connection
                setTimeout(() => {
                    if (!conn.open) {
                        showStatus('Connection timeout. Make sure the host is online!', true);
                        console.error('Connection timeout to host:', hostPeerId);
                    }
                }, 10000);
                
            } catch (err) {
                showStatus('Failed to join room: ' + err.message, true);
                console.error('Join room error:', err);
            }
        }

        function updateWaitingRoom() {
            const list = document.getElementById('players-list');
            list.innerHTML = '';
            
            players.forEach(p => {
                const li = document.createElement('li');
                li.textContent = p.name + (p.id === localPlayerId ? ' (You)' : '');
                li.style.borderLeft = `4px solid ${p.color}`;
                list.appendChild(li);
            });
            
            if (isHost && players.size >= 1) {
                document.getElementById('start-race').style.display = 'block';
            }
            
            console.log('Waiting room updated. Players:', players.size);
        }

        // ============================================
        // SCOREBOARD
        // ============================================
        function updateScoreboard() {
            const content = document.getElementById('scoreboard-content');
            content.innerHTML = '';
            
            const sorted = Array.from(players.values()).sort((a, b) => {
                if (a.finished && b.finished) return a.finishTime - b.finishTime;
                if (a.finished) return -1;
                if (b.finished) return 1;
                if (a.lap !== b.lap) return b.lap - a.lap;
                return b.checkpoint - a.checkpoint;
            });
            
            sorted.forEach((p, i) => {
                const div = document.createElement('div');
                div.className = 'scoreboard-row' + (p.id === localPlayerId ? ' you' : '');
                div.style.borderLeftColor = p.color;
                
                const pos = i + 1;
                const suffix = ['st', 'nd', 'rd'][pos - 1] || 'th';
                
                div.innerHTML = `
                    <span class="scoreboard-position">${pos}${suffix}</span>
                    <span class="scoreboard-name">${p.name}</span>
                    <span class="scoreboard-lap">L${p.lap + 1}/3</span>
                `;
                content.appendChild(div);
            });
        }

        // ============================================
        // QUESTION SYSTEM
        // ============================================
        function initQuestions() {
            let filtered = [...questionBank];
            if (selectedCategory !== 'all') {
                filtered = filtered.filter(q => q.category === selectedCategory);
            }
            if (selectedDifficulty !== 'all') {
                filtered = filtered.filter(q => q.difficulty === selectedDifficulty);
            }
            
            questions = [];
            const num = Math.min(6, filtered.length);
            const spacing = Math.floor(track.length / num);
            
            for (let i = 0; i < num; i++) {
                if (filtered.length === 0) break;
                const idx = Math.floor(Math.random() * filtered.length);
                const q = filtered.splice(idx, 1)[0];
                const trackIdx = (spacing * i + Math.floor(spacing / 2)) % track.length;
                const pos = track[trackIdx];
                
                questions.push({
                    id: `q${i}`,
                    x: pos.x,
                    y: pos.y,
                    question: q,
                    collected: false
                });
            }
            console.log('Questions placed:', questions.length);
        }

        function showQuestion(q) {
            currentQuestion = q;
            questionTimer = QUESTION_TIME;
            
            document.getElementById('question-category').textContent = q.category;
            document.getElementById('question-text').textContent = q.question;
            
            const opts = document.getElementById('options');
            opts.innerHTML = '';
            q.options.forEach((opt, i) => {
                const btn = document.createElement('button');
                btn.className = 'option-btn';
                btn.textContent = opt;
                btn.onclick = () => answerQuestion(i);
                opts.appendChild(btn);
            });
            
            document.getElementById('explanation').style.display = 'none';
            document.getElementById('question-popup').classList.remove('hidden');
        }

        function answerQuestion(index) {
            if (!currentQuestion) return;
            
            const correct = index === currentQuestion.correct;
            const buttons = document.querySelectorAll('.option-btn');
            const localPlayer = players.get(localPlayerId);
            
            buttons.forEach((btn, i) => {
                btn.disabled = true;
                btn.onclick = null;
                if (i === currentQuestion.correct) {
                    btn.classList.add('correct');
                } else if (i === index && !correct) {
                    btn.classList.add('wrong');
                }
            });
            
            if (currentQuestion.explanation) {
                document.getElementById('explanation').textContent = currentQuestion.explanation;
                document.getElementById('explanation').style.display = 'block';
            }
            
            if (correct) {
                localPlayer.boost = BOOST_TIME;
                localPlayer.questionsCorrect++;
                localPlayer.questionsThisLap++;
                playSound(800, 0.3);
                
                const notif = document.getElementById('boost-notification');
                notif.style.display = 'block';
                setTimeout(() => notif.style.display = 'none', 1500);
                
                for (let i = 0; i < 40; i++) {
                    createParticle(localPlayer.x, localPlayer.y, localPlayer.color, 7,
                        (Math.random() - 0.5) * 12, (Math.random() - 0.5) * 12, 50);
                }
            } else {
                localPlayer.slow = SLOW_TIME;
                playSound(200, 0.3);
            }
            
            setTimeout(() => {
                document.getElementById('question-popup').classList.add('hidden');
                currentQuestion = null;
            }, 2500);
        }

        // ============================================
        // PHYSICS
        // ============================================
        function distance(a, b) {
            return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);
        }

        function getClosestTrackIndex(pos) {
            let minDist = Infinity;
            let idx = 0;
            for (let i = 0; i < track.length; i++) {
                const d = distance(pos, track[i]);
                if (d < minDist) {
                    minDist = d;
                    idx = i;
                }
            }
            return idx;
        }

        function distanceToTrack(pos) {
            let minDist = Infinity;
            for (let i = 0; i < track.length; i++) {
                const next = track[(i + 1) % track.length];
                const d = distanceToSegment(pos, track[i], next);
                minDist = Math.min(minDist, d);
            }
            return minDist;
        }

        function distanceToSegment(p, a, b) {
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const t = Math.max(0, Math.min(1, ((p.x - a.x) * dx + (p.y - a.y) * dy) / (dx * dx + dy * dy)));
            const nearX = a.x + t * dx;
            const nearY = a.y + t * dy;
            return Math.sqrt((p.x - nearX) ** 2 + (p.y - nearY) ** 2);
        }

        // ============================================
        // PARTICLES
        // ============================================
        function createParticle(x, y, color, size, vx, vy, life) {
            particles.push({x, y, color, size, vx, vy, life, maxLife: life});
        }

        function updateParticles() {
            particles = particles.filter(p => {
                p.x += p.vx;
                p.y += p.vy;
                p.vx *= 0.97;
                p.vy *= 0.97;
                p.life--;
                return p.life > 0;
            });
        }

        // ============================================
        // GAME LOOP
        // ============================================
        function update() {
            if (!raceStarted) return;
            
            updateParticles();
            
            const localPlayer = players.get(localPlayerId);
            if (!localPlayer || localPlayer.finished) return;

            if (localPlayer.boost > 0) {
                document.getElementById('effect-overlay').className = 'boost';
                if (Math.random() < 0.5) {
                    const angle = localPlayer.angle + Math.PI;
                    createParticle(
                        localPlayer.x + Math.cos(angle) * 20,
                        localPlayer.y + Math.sin(angle) * 20,
                        localPlayer.color, 5, Math.cos(angle) * 4, Math.sin(angle) * 4, 35
                    );
                }
            } else if (localPlayer.slow > 0) {
                document.getElementById('effect-overlay').className = 'slow';
            } else if (document.getElementById('effect-overlay').className !== 'crash') {
                document.getElementById('effect-overlay').className = '';
            }

            const input = {
                up: (keys.up || touchAccel) && !currentQuestion,
                down: (keys.down || touchBrake) && !currentQuestion,
                left: (keys.left || touchLeft) && !currentQuestion,
                right: (keys.right || touchRight) && !currentQuestion
            };
            
            if (currentQuestion) {
                localPlayer.speed = 0;
                localPlayer.vx = 0;
                localPlayer.vy = 0;
            }
            
            localPlayer.update(input);

            players.forEach(other => {
                if (other.id !== localPlayer.id) {
                    localPlayer.handleCollision(other);
                }
            });

            if (questionsPlaced) {
                questions.forEach(q => {
                    if (!q.collected && distance(localPlayer, q) < 70) {
                        q.collected = true;
                        showQuestion(q.question);
                        
                        broadcast({
                            type: 'question-collected',
                            questionId: q.id
                        });
                    }
                });
            }

            if (currentQuestion) {
                questionTimer--;
                const sec = Math.ceil(questionTimer / 60);
                document.getElementById('timer').textContent = sec;
                document.getElementById('timer').className = sec <= 5 ? 'warning' : '';
                
                if (questionTimer <= 0) {
                    answerQuestion(-1);
                }
            }

            // Send updates to other players
            if (connections.size > 0) {
                broadcast({
                    type: 'player-update',
                    playerId: localPlayerId,
                    playerData: localPlayer.toData()
                });
            }

            cameraX += (localPlayer.x - cameraX) * CAMERA_SMOOTHING;
            cameraY += (localPlayer.y - cameraY) * CAMERA_SMOOTHING;

            function normalize(a) { return Math.atan2(Math.sin(a), Math.cos(a)); }
            const desiredAngle = normalize(localPlayer.angle + Math.PI / 2);
            const diff = normalize(desiredAngle - cameraAngle);
            cameraAngle = normalize(cameraAngle + diff * CAMERA_SMOOTHING);

            document.getElementById('speed-display').textContent = Math.round(localPlayer.speed * 25);
            document.getElementById('lap-display').textContent = `${Math.min(localPlayer.lap + 1, 3)}/3`;
            document.getElementById('correct-display').textContent = localPlayer.questionsCorrect;
            document.getElementById('pos-display').textContent = getPosition(localPlayer);

            updateScoreboard();

            if (allFinished()) {
                setTimeout(() => showResults(), 2000);
            }
        }

        function getPosition(player) {
            const sorted = Array.from(players.values()).sort((a, b) => {
                if (a.finished && b.finished) return a.finishTime - b.finishTime;
                if (a.finished) return -1;
                if (b.finished) return 1;
                if (a.lap !== b.lap) return b.lap - a.lap;
                return b.checkpoint - a.checkpoint;
            });
            const pos = sorted.findIndex(p => p.id === player.id) + 1;
            const suffix = ['st', 'nd', 'rd'][pos - 1] || 'th';
            return pos + suffix;
        }

        function allFinished() {
            return Array.from(players.values()).every(p => p.finished);
        }

        // ============================================
        // RENDERING
        // ============================================
        function render() {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(canvas.width / 2, canvas.height / 2 + CAMERA_Y_OFFSET);
            ctx.rotate(-cameraAngle);
            ctx.scale(ZOOM, ZOOM);
            ctx.translate(-cameraX, -cameraY);

            // Grass
            ctx.fillStyle = '#001100';
            const grassSize = 40;
            const startX = Math.floor((cameraX - canvas.width / (2 * ZOOM)) / grassSize) * grassSize;
            const endX = cameraX + canvas.width / (2 * ZOOM);
            const startY = Math.floor((cameraY - canvas.height / (2 * ZOOM)) / grassSize) * grassSize;
            const endY = cameraY + canvas.height / (2 * ZOOM);
            
            for (let x = startX; x < endX; x += grassSize) {
                for (let y = startY; y < endY; y += grassSize) {
                    if ((x + y) % (grassSize * 2) === 0) {
                        ctx.fillRect(x, y, grassSize / 2, grassSize / 2);
                    }
                }
            }

            // Track
            ctx.strokeStyle = '#003300';
            ctx.lineWidth = TRACK_WIDTH * 2.3;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.beginPath();
            ctx.moveTo(track[0].x, track[0].y);
            track.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.stroke();

            ctx.strokeStyle = '#111';
            ctx.lineWidth = TRACK_WIDTH * 2;
            ctx.beginPath();
            ctx.moveTo(track[0].x, track[0].y);
            track.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.stroke();

            ctx.strokeStyle = 'rgba(0,255,0,0.3)';
            ctx.lineWidth = 3;
            ctx.setLineDash([25, 25]);
            ctx.beginPath();
            ctx.moveTo(track[0].x, track[0].y);
            track.forEach(p => ctx.lineTo(p.x, p.y));
            ctx.closePath();
            ctx.stroke();
            ctx.setLineDash([]);

            // Track crossings
            if (trackCrossings && trackCrossings.length) {
                trackCrossings.forEach(c => {
                    ctx.save();
                    ctx.translate(c.x, c.y);
                    ctx.rotate(c.angle);
                    ctx.fillStyle = 'rgba(0,255,0,0.95)';
                    ctx.beginPath();
                    ctx.moveTo(0, -10);
                    ctx.lineTo(8, 0);
                    ctx.lineTo(0, 8);
                    ctx.closePath();
                    ctx.fill();
                    ctx.rotate(Math.PI);
                    ctx.globalAlpha = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(0, -6);
                    ctx.lineTo(6, 0);
                    ctx.lineTo(0, 6);
                    ctx.closePath();
                    ctx.fill();
                    ctx.globalAlpha = 1;
                    ctx.restore();
                });
            }

            // Start/finish
            ctx.save();
            ctx.translate(track[0].x, track[0].y);
            ctx.rotate(FINISH_LINE_ANGLE + Math.PI / 2);
            for (let i = -7; i <= 7; i++) {
                ctx.fillStyle = i % 2 === 0 ? '#0f0' : '#000';
                ctx.fillRect(i * 18, -14, 18, 28);
            }
            ctx.restore();

            // Particles
            particles.forEach(p => {
                ctx.globalAlpha = p.life / p.maxLife;
                ctx.fillStyle = p.color;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.globalAlpha = 1;

            // Questions
            if (questionsPlaced) {
                questions.forEach(q => {
                    if (!q.collected) {
                        ctx.save();
                        ctx.shadowColor = '#ff0';
                        ctx.shadowBlur = 25;
                        ctx.fillStyle = '#ff0';
                        ctx.beginPath();
                        ctx.arc(q.x, q.y, 25, 0, Math.PI * 2);
                        ctx.fill();
                        ctx.shadowBlur = 0;
                        ctx.fillStyle = '#000';
                        ctx.font = 'bold 32px Arial';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText('?', q.x, q.y);
                        ctx.restore();
                    }
                });
            }

            // Players
            players.forEach(p => {
                ctx.save();
                ctx.translate(p.x, p.y);
                ctx.rotate(p.angle);
                
                ctx.fillStyle = 'rgba(0,0,0,0.4)';
                ctx.fillRect(-CAR_LENGTH/2 + 3, -CAR_WIDTH/2 + 3, CAR_LENGTH, CAR_WIDTH);
                
                ctx.fillStyle = p.crashStun > 0 ? '#f00' : p.color;
                ctx.fillRect(-CAR_LENGTH/2, -CAR_WIDTH/2, CAR_LENGTH, CAR_WIDTH);
                
                ctx.fillStyle = 'rgba(0,0,0,0.6)';
                ctx.fillRect(-CAR_LENGTH/4, -CAR_WIDTH/2 + 3, CAR_LENGTH/2, CAR_WIDTH - 6);
                
                ctx.fillStyle = '#000';
                [-CAR_LENGTH/2 + 6, CAR_LENGTH/2 - 10].forEach(wx => {
                    [-CAR_WIDTH/2 - 4, CAR_WIDTH/2].forEach(wy => {
                        ctx.fillRect(wx, wy, 10, 5);
                    });
                });
                
                ctx.fillStyle = p.crashStun > 0 ? '#f00' : '#fff';
                ctx.fillRect(CAR_LENGTH/2 - 3, -CAR_WIDTH/2 + 3, 3, 4);
                ctx.fillRect(CAR_LENGTH/2 - 3, CAR_WIDTH/2 - 7, 3, 4);
                
                ctx.fillStyle = p.color;
                ctx.font = 'bold 11px Arial';
                ctx.textAlign = 'center';
                ctx.shadowColor = '#000';
                ctx.shadowBlur = 3;
                ctx.fillText(p.name, 0, -CAR_WIDTH - 10);
                ctx.shadowBlur = 0;
                
                ctx.restore();
            });

            ctx.restore();

            renderMinimap();
        }

        function renderMinimap() {
            const scale = 0.028;
            const cx = 90;
            const cy = 90;
            
            minimapCtx.fillStyle = '#000';
            minimapCtx.fillRect(0, 0, 180, 180);
            
            minimapCtx.strokeStyle = '#0f0';
            minimapCtx.lineWidth = 10;
            minimapCtx.beginPath();
            minimapCtx.moveTo(cx + (track[0].x - GAME_WIDTH/2) * scale, cy + (track[0].y - GAME_HEIGHT/2) * scale);
            track.forEach(p => {
                minimapCtx.lineTo(cx + (p.x - GAME_WIDTH/2) * scale, cy + (p.y - GAME_HEIGHT/2) * scale);
            });
            minimapCtx.closePath();
            minimapCtx.stroke();
            
            if (questionsPlaced) {
                questions.forEach(q => {
                    if (!q.collected) {
                        minimapCtx.fillStyle = '#ff0';
                        minimapCtx.beginPath();
                        minimapCtx.arc(
                            cx + (q.x - GAME_WIDTH/2) * scale,
                            cy + (q.y - GAME_HEIGHT/2) * scale,
                            5, 0, Math.PI * 2
                        );
                        minimapCtx.fill();
                    }
                });
            }
            
            players.forEach(p => {
                minimapCtx.fillStyle = p.color;
                minimapCtx.beginPath();
                minimapCtx.arc(
                    cx + (p.x - GAME_WIDTH/2) * scale,
                    cy + (p.y - GAME_HEIGHT/2) * scale,
                    7, 0, Math.PI * 2
                );
                minimapCtx.fill();
            });
        }

        function gameLoop() {
            update();
            render();
            if (raceStarted && !allFinished()) {
                requestAnimationFrame(gameLoop);
            }
        }

        // ============================================
        // UTILITIES
        // ============================================
        function playSound(freq, duration) {
            try {
                const ctx = new (window.AudioContext || window.webkitAudioContext)();
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                osc.connect(gain);
                gain.connect(ctx.destination);
                osc.frequency.value = freq;
                gain.gain.value = 0.1;
                osc.start();
                osc.stop(ctx.currentTime + duration);
            } catch (e) {}
        }

        function showInstruction(text, duration = 3000) {
            const inst = document.getElementById('instruction');
            inst.textContent = text;
            inst.classList.remove('hidden');
            setTimeout(() => inst.classList.add('hidden'), duration);
        }

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        function startRace() {
            if (isHost) {
                console.log('Host starting race, broadcasting to all players');
                broadcast({type: 'start-race'});
            }
            
            questionsPlaced = false;
            questions = [];
            
            players.forEach(p => {
                p.x = track[0].x;
                p.y = track[0].y;
                p.vx = 0;
                p.vy = 0;
                p.angle = FINISH_LINE_ANGLE;
                p.speed = 0;
                p.lap = 0;
                p.checkpoint = 0;
                p.boost = 0;
                p.slow = 0;
                p.crashStun = 0;
                p.questionsCorrect = 0;
                p.questionsThisLap = 0;
                p.finished = false;
                p.finishTime = null;
                p.crossedStartFromBehind = false;
            });
            
            cameraX = track[0].x;
            cameraY = track[0].y;
            particles = [];
            
            showScreen('countdown');
            
            let count = 3;
            const interval = setInterval(() => {
                document.getElementById('countdown-text').textContent = count === 0 ? 'GO!' : count;
                if (count === 0) playSound(1000, 0.2);
                count--;
                if (count < -1) {
                    clearInterval(interval);
                    document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
                    raceStarted = true;
                    startTime = Date.now();
                    document.getElementById('race-hud').style.display = 'block';
                    document.getElementById('scoreboard').style.display = 'block';
                    document.getElementById('controls').style.display = 'block';
                    showInstruction('üèÅ LAP 1: Just race! Questions unlock after lap 1!', 5000);
                    gameLoop();
                }
            }, 1000);
        }

        function showResults() {
            raceStarted = false;
            document.getElementById('race-hud').style.display = 'none';
            document.getElementById('scoreboard').style.display = 'none';
            document.getElementById('controls').style.display = 'none';
            
            const sorted = Array.from(players.values()).sort((a, b) => {
                if (a.finished && b.finished) return a.finishTime - b.finishTime;
                if (a.finished) return -1;
                if (b.finished) return 1;
                return 0;
            });
            
            const content = document.getElementById('results-content');
            content.innerHTML = '';
            
            sorted.forEach((p, i) => {
                const div = document.createElement('div');
                const classes = ['first', 'second', 'third'];
                div.className = 'result-item' + (classes[i] ? ' ' + classes[i] : '');
                div.style.borderLeft = `5px solid ${p.color}`;
                const time = p.finished ? (p.finishTime / 1000).toFixed(2) + 's' : 'DNF';
                const medal = ['ü•á', 'ü•à', 'ü•â'][i] || `${i+1}.`;
                div.innerHTML = `
                    <span>${medal} ${p.name}</span>
                    <span>‚úì${p.questionsCorrect} | ${time}</span>
                `;
                content.appendChild(div);
            });
            
            showScreen('results');
        }

        // ============================================
        // CONTROLS
        // ============================================
        window.addEventListener('keydown', e => {
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = true;
            if (e.key === 'ArrowRight' || e.key === 'd') keys.right = true;
            if (e.key === 'ArrowUp' || e.key === 'w') keys.up = true;
            if (e.key === 'ArrowDown' || e.key === 's') keys.down = true;
        });
        window.addEventListener('keyup', e => {
            if (e.key === 'ArrowLeft' || e.key === 'a') keys.left = false;
            if (e.key === 'ArrowRight' || e.key === 'd') keys.right = false;
            if (e.key === 'ArrowUp' || e.key === 'w') keys.up = false;
            if (e.key === 'ArrowDown' || e.key === 's') keys.down = false;
        });

        function setupTouch(id, onStart, onEnd) {
            const el = document.getElementById(id);
            el.addEventListener('touchstart', e => {
                e.preventDefault();
                el.classList.add('active');
                onStart();
            });
            el.addEventListener('touchend', e => {
                e.preventDefault();
                el.classList.remove('active');
                onEnd();
            });
        }

        setupTouch('steer-left', () => touchLeft = true, () => touchLeft = false);
        setupTouch('steer-right', () => touchRight = true, () => touchRight = false);
        setupTouch('accelerate', () => touchAccel = true, () => touchAccel = false);
        setupTouch('brake', () => touchBrake = true, () => touchBrake = false);

        // ============================================
        // EVENT LISTENERS
        // ============================================
        document.getElementById('play-solo').addEventListener('click', () => {
            playerName = document.getElementById('player-name').value.trim() || 'Racer';
            localStorage.setItem('playerName', playerName);
            selectedCategory = document.getElementById('category-select').value;
            selectedDifficulty = document.getElementById('difficulty-select').value;
            
            localPlayerId = 'solo';
            isHost = true;
            const localPlayer = new Player(localPlayerId, playerName, 0);
            players.set(localPlayerId, localPlayer);
            
            startRace();
        });

        document.getElementById('create-room').addEventListener('click', () => {
            playerName = document.getElementById('player-name').value.trim() || 'Racer';
            if (!playerName) {
                showStatus('Please enter your name', true);
                return;
            }
            localStorage.setItem('playerName', playerName);
            selectedCategory = document.getElementById('category-select').value;
            selectedDifficulty = document.getElementById('difficulty-select').value;
            createRoom();
        });

        document.getElementById('join-room').addEventListener('click', () => {
            playerName = document.getElementById('player-name').value.trim() || 'Racer';
            if (!playerName) {
                showStatus('Please enter your name', true);
                return;
            }
            localStorage.setItem('playerName', playerName);
            selectedCategory = document.getElementById('category-select').value;
            selectedDifficulty = document.getElementById('difficulty-select').value;
            joinRoom();
        });

        document.getElementById('start-race').addEventListener('click', () => {
            if (players.size < 1) {
                showStatus('Need at least 1 player to start', true);
                return;
            }
            startRace();
        });

        document.getElementById('copy-link-btn').addEventListener('click', copyRoomLink);

        document.getElementById('leave-room').addEventListener('click', () => {
            if (peer && !peer.destroyed) {
                peer.destroy();
            }
            connections.clear();
            players.clear();
            questionsPlaced = false;
            questions = [];
            showScreen('lobby');
        });

        document.getElementById('race-again').addEventListener('click', () => {
            showScreen('waiting-room');
        });

        document.getElementById('back-to-menu').addEventListener('click', () => {
            if (peer && !peer.destroyed) {
                peer.destroy();
            }
            connections.clear();
            players.clear();
            questionsPlaced = false;
            questions = [];
            showScreen('lobby');
        });

        // Make room code input uppercase
        document.getElementById('room-code').addEventListener('input', function() {
            this.value = this.value.toUpperCase();
        });

        document.getElementById('player-name').value = playerName;
        
        console.log('Game initialized - ready to play!');
    </script>
</body>
</html>